
# Harris RPC 框架
Harris RPC 框架是一个基于 Java 的轻量级 RPC 框架，旨在帮助实现远程过程调用和分布式通信。该框架使用 Netty 进行网络通信，采用 Kryo 进行高效的序列化，同时利用 Nacos 实现服务注册与发现

## 模块概览
本项目由多个模块组成，每个模块负责不同的功能和用途

### 1. rpc-api
定义了通用服务接口和其中的实体类，用于客户端和服务端之间的数据传输

### 2. rpc-common
定义了用于远程调用的通用实体类、枚举以及异常，也就是一种传输格式。这些类提供了在客户端和服务端之间进行数据传输所需的结构和信息

#### 传输协议格式
1 远程调用请求 `RpcRequest`，为了唯一确定服务端需要调用的接口方法，需要了解以下信息：
1. 接口名 `String interfaceName;`
2. 方法名 `String methodName;`
3. 参数类型 `Class<?>[] paramTypes;`：考虑到方法重载，需要包括调用方法的所有参数的类型信息。
4. 参数实际值 `Object[] parameters;`：在客户端调用时，需要传递参数的实际值。

2 远程调用响应 `RpcResponse`，服务端对客户端请求的响应，其中包含：
1. 响应状态码 `Integer statusCode;`
2. 响应状态信息 `String message;`
3. 响应数据 `T data;`

3 各种枚举类和异常类

### 3. rpc-core
#### 客户端
`RpcClient` 是客户端的核心类，它负责与远程服务器建立连接，并通过网络发送和接收远程调用请求与响应。
它实现了远程调用的过程，将用户的方法调用转化为网络数据传输

#### 服务端
`RpcServer` 是服务端的核心类，它负责监听指定的端口，接收来自客户端的远程调用请求。
一旦接收到请求，RpcServer 将根据请求的内容进行路由和处理，然后将处理结果返回给客户端。通过这个类，服务端可以注册多个服务，以便处理不同的远程调用请求

### 4. test-client
`test-client` 模块展示了 Harris RPC 框架的客户端功能。连接到运行中的服务器并发起远程方法调用请求

### 5. test-server
`test-server` 模块展示了 Harris RPC 框架的服务端功能。注册了提供的各类服务，并在接收到客户端请求时提供相应的响应

## 项目发展

### 1. feat: basic rpc framework
初步实现了一个基础的RPC框架，采用了JDK序列化和Socket通信方式。 目前实现了基本的远程方法调用功能。
在这个阶段，我们成功地注册了一个名为 helloService 的服务，但是框架限制了每个服务器只能注册一个服务，因为在注册完服务后，服务器就自行启动了

下一步，将服务的注册和服务器启动分离，使得服务端可以提供多个服务

### 2. feat: multi-service support
在这个功能增强中，我们引入了服务注册表机制，以便实现服务的注册和发现。这个机制通过 ServiceRegistry 接口来实现，该接口定义了服务注册和获取的方法。
借助于 ServiceRegistryImpl 类的实现，服务现在可以根据其接口名进行注册，并且可以根据接口名来获取对应的服务实体。这为更灵活的服务处理提供了基础

为了增强服务请求处理逻辑，我们对 RequestHandler 类进行了优化。它现在能够处理多个不同服务的请求。
当收到客户端请求后，RequestHandler 会根据请求的接口名识别相应的服务实体，并调用适当的方法进行处理

我们的框架在服务器端的能力得到了扩展，以支持多个服务。RpcServer 已经得到增强，可以同时注册和处理多个服务。
在服务器启动时，例如在 TestServer 类中，我们可以使用 ServiceRegistry 注册类似 HelloService 的服务。
当客户端请求到达时，RpcServer 会将请求智能路由到正确的服务进行处理

为了确保并发处理多个客户端请求，我们采用了多线程方法。
我们引入了 RequestHandlerThread 类，每个类都在单独的线程中处理一个传入的 RpcRequest。这确保了请求的高效和响应迅速

此外，通过引入自定义的 RpcException 类，我们增强了异常处理。这有助于更好地管理和传递可能在 RPC 框架中出现的异常情况，提高了系统的健壮性

### 3. feat: netty communication
引入了 Netty 作为通信框架，取代了之前的基于 Socket 的通信方式

